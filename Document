This documentation is prepared for the **Scenario Board Review**. It outlines the architectural design, deployment automation, and identity governance for the HashiCorp Vault implementation on Amazon EKS.

---

# Design Document: Automated Vault Deployment & Identity Federation

## 1. Executive Summary

This project implements a highly available, self-bootstrapping **HashiCorp Vault** instance hosted on **Amazon EKS**. The solution solves the "initialization gap" in standard Terraform providers by using a custom Kubernetes-native operator pattern and integrates **Keycloak SSO** for automated, group-based access control.

---

## 2. Infrastructure & Environment

* **Orchestration:** Amazon Elastic Kubernetes Service (EKS).
* **Image Management:** All container images (Vault, Keycloak, and custom init-scripts) are stored in a **Private Container Registry** to ensure supply chain security.
* **Configuration Management:** Terraform is used for both infrastructure provisioning (EKS resources) and post-initialization Vault configuration.

---

## 3. Automated Bootstrapping (The "Operator" Pattern)

Standard Terraform providers cannot perform the initial `vault operator init` because the Vault API is unreachable until the cluster is initialized.

### 3.1 The `operator.tf` Workflow

To automate the lifecycle, we have implemented a custom orchestration layer:

1. **Kubernetes Job:** Terraform deploys a K8s Job (defined in `operator.tf`) that monitors the Vault pods.
2. **Initialization Script:** Once Vault is "Ready," the job executes a script inside the cluster to run `vault operator init -format=json`.
3. **The Initialization Process:**
* Generates **5 Unseal Key Shares** and **1 Initial Root Token**.
* Configures the storage backend (Consul, Raft, or S3) to transition from `uninitialized` to `sealed`.


4. **Secure Log Extraction:** * A sidecar or post-processing logic extracts the JSON output from the job logs.
* **K8s Secret Storage:** The script automatically encodes and stores the Unseal Keys and Root Token into a **Kubernetes Secret** (e.g., `vault-unseal-keys`).
* *Security Note: Access to this specific K8s secret is restricted via strict RBAC to cluster administrators only.*



---

## 4. Identity & Access Governance (SSO)

Access to Vault is not managed via local users. Instead, we use **Identity Federation** via Keycloak (also hosted on EKS).

### 4.1 Keycloak Integration (OIDC)

We have configured an OpenID Connect (OIDC) mount in Vault that points to the Keycloak Realm. This removes the need for static credentials and leverages existing corporate identities.

### 4.2 Group-Based Policy Mapping

The core of our security model is the automated mapping of Keycloak attributes to Vault permissions:

1. **Keycloak Groups:** Users are assigned to specific groups in Keycloak (e.g., `App-Dev-Team-Alpha`, `Security-Admins`).
2. **JWT Claims:** When a user logs in, Keycloak issues a JWT containing a `groups` claim.
3. **Vault Group Aliases:** Terraform creates **External Groups** in Vault. Each external group is linked to a **Group Alias** that matches the name of the Keycloak group.
4. **Policy Inheritance:** * Vault policies (defining path-level CRUD permissions) are attached to these Vault Groups.
* **The Result:** A user in the `App-Dev` group in Keycloak automatically inherits the "Developer" policy in Vault upon login.



| Component | Entity | Responsibility |
| --- | --- | --- |
| **Identity Provider** | Keycloak Group | Defines user membership and organizational role. |
| **Intermediary** | Vault Group Alias | Maps the Keycloak "Group Name" to a Vault "Identity." |
| **Authorizer** | Vault Policy | Defines exactly which secrets (paths) the group can access. |

---

## 5. Security Posture & Compliance

* **Encryption at Rest:** All secrets stored in Vault are encrypted using AES-GCM-256.
* **Audit Logging:** All interactions (including the automated initialization job) are logged to the EKS FluentBit/CloudWatch pipeline.
* **Isolation:** Vault and Keycloak reside in dedicated K8s Namespaces with Network Policies preventing unauthorized cross-pod communication.


2. Phase I: The Bootstrapping Logic (operator.tf)
Since standard Terraform providers cannot interact with an uninitialized Vault API, we have implemented a custom orchestration pattern to automate the "Day 0" setup.

2.1 The Kubernetes Initialization Job
We use a Terraform kubernetes_job resource (defined in operator.tf) to handle the initialization process.

Execution Workflow:

Orchestration: Once the Vault statefulset is deployed, Terraform triggers a K8s Job. This job runs a custom script designed to monitor the Vault pods until they are in a "Ready" state.

Vault Initialization: The script executes vault operator init -format=json.

This process generates 5 Unseal Key Shares and 1 Initial Root Token.

Vault transitions from an "uninitialized" state to a "sealed" state.

Credential Capture & Secure Storage: * The script acts as a Log Extractor: it captures the JSON output of the initialization command.

Instead of outputting these secrets to the job logs (which would be insecure), the script programmatically creates a Kubernetes Secret within the cluster.

This secret contains the unseal keys and the root token, allowing for subsequent automated unseal operations or administrative configuration.

3. Phase II: Identity Federation (Keycloak & SSO)
Once initialized, Vault is configured to delegate authentication to Keycloak (also hosted on EKS) using the OpenID Connect (OIDC) protocol.

3.1 OIDC Configuration
Terraform configures the Vault OIDC auth method to trust our Keycloak realm. This setup includes defining a JWT role that maps the groups claim from the Keycloak token to Vault's internal identity system.

3.2 External Group Mapping Logic
Our security model relies on External Groups to ensure that permissions are managed dynamically without manual intervention in Vault.

Source of Truth (Keycloak): All user groups (e.g., Dev-Ops, Security-Audit) are created and managed directly within Keycloak.

The Vault Link (Terraform): 1. External Identity Group: Terraform creates a vault_identity_group in Vault and sets its type to external. 2. Group Alias: Terraform then creates a vault_identity_group_alias. This alias acts as the "bridge." It matches the specific Group Name existing in Keycloak to the External Group ID in Vault. 3. Policy Inheritance: We attach specific Vault HCL policies to the External Group.

The Authentication Flow:

A user logs into Vault via the OIDC/Keycloak method.

Keycloak provides a JWT containing the user's group memberships.

Vault sees the group name in the JWT, matches it via the Group Alias, and automatically assigns the user the corresponding Vault Policies.
---

### Next Steps for the Board

Would you like me to **draft the specific HCL (Terraform code)** for the `vault_identity_group` and `vault_jwt_auth_backend_role` resources to demonstrate the Keycloak mapping?
